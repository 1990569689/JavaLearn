public interface J {
    // 定义一个j接口
    /*
     * 
     * 接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。
     * 
     * 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。
     * 
     * 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java
     * 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。
     * 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，
     * 这样的类就是抽象类。
     * 
     * 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。
     * 
     * 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。
     * 
     * 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。
     * 
     * 在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口
     * 
     * 接口特性
     * 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public
     * abstract，其他修饰符都会报错）。
     * 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private
     * 修饰会报编译错误）。
     * 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。
     * 抽象类和接口的区别
     * 1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。
     * 2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。
     * 3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
     * 4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。
     * 接口有以下特性：
     * 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。
     * 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。
     * 接口中的方法都是公有的。
     * 重写接口中声明的方法时，需要注意以下规则：
     * 
     * 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。
     * 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。
     * 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。
     * 在实现接口的时候，也要注意一些规则：
     * 
     * 一个类可以同时实现多个接口。
     * 一个类只能继承一个类，但是能实现多个接口。
     * 一个接口能继承另一个接口，这和类之间的继承比较相似。
     * 接口的多继承
     * 在Java中，类的多继承是不合法，但接口允许多继承。
     * 
     * 在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：
     * 
     * public interface Hockey extends Sports, Event
     * 
     * 标记接口
     * 最常用的继承接口是没有包含任何方法的接口。
     * 
     * 标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。
     * 
     * 标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。
     * 
     * 例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：
     * 
     * package java.util;
     * public interface EventListener
     * {}
     * 没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：
     * 
     * 建立一个公共的父接口：
     * 正如EventListener接口，这是由几十个其他接口扩展的Java
     * API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)
     * 就知道该接口将要被用于一个事件的代理方案。
     * 
     * 向一个类添加数据类型：
     * 这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。
     */
    public void SetName(String name);
//定义一个接口里面定义方法是没有方法体的 因为他是默认抽象接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。
    public void GetName();

}
